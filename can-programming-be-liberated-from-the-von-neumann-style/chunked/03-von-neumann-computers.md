> 3. Von Neumann Computers 

## 3. 冯·诺伊曼计算机

> In order to understand the problems of conventional programming languages, we must first examine their intellectual parent, the von Neumann computer. What is a von Neumann computer? When von Neumann and others conceived it over thirty years ago, it was an elegant, practical, and unifying idea that simplified a number of engineering and programming problems that existed then. Although the conditions that produced its architecture have changed radically, we nevertheless still identify the notion of "computer" with this thirty year old concept. 

为了理解传统编程语言存在的问题，我们首先需要研究它们的“智力先父”（Intellectual Parent），冯·诺伊曼计算机。什么是冯·诺伊曼计算机？三十多年前，冯·诺伊曼等人构思出这个概念时，它还是一个优雅、实用且统一的思想，简化了许多当时存在的工程和编程问题。尽管催生冯·诺伊曼架构的条件已经发生根本性变化，但我们仍然将“计算机”的概念与这个三十年前的概念联系在一起。

> In its simplest form a von Neumann computer has three parts: a central processing unit (or CPU), a store, and a connecting tube that can transmit a single word between the CPU and the store (and send an address to the store). I propose to call this tube the von Neumann bottleneck. The task of a program is to change the contents of the store in some major way; when one considers that this task must be accomplished entirely by pumping single words back and forth through the von Neumann bottleneck, the reason for its name becomes clear. 

冯·诺伊曼计算机最简单的形式由三个部分组成：中央处理单元 (CPU)、存储器和连接管道。这条管道可以在 CPU 和存储器之间传输单个字 (Word)（同时可以向存储器发送地址）。我愿将这条管道称为冯·诺伊曼瓶颈。要知道，程序的任务是大幅改变存储器的内容，这一过程必须是一个字一个字地通过这条瓶颈来回传输来完成的，冯·诺伊曼瓶颈才得名于此。

> Ironically, a large part of the traffic in the bottleneck is not useful data but merely names of data, as well as operations and data used only to compute such names. Before a word can be sent through the tube its address must be in the CPU; hence it must either be sent through the tube from the store or be generated by some CPU operation. If the address is sent from the store, then its address must either have been sent from the store or generated in the CPU, and so on. If, on the other hand, the address is generated in the CPU, it must be generated either by a fixed rule (e.g., "add l to the program counter") or by an instruction that was sent through the tube, in which case its address must have been sent ... and so on.

讽刺的是，瓶颈里的大部分数据流并不是真正有用的数据，而仅仅是数据的名称、用于计算这些名称的操作和数据本身。因为在一个字通过管道发送之前，它的地址必须已经在 CPU 中；因此，它要么需要从存储器通过管道发送到 CPU，要么由某个 CPU 操作生成。 如果地址从存储器发送，那么它的地址要么必须已经从存储器发送，要么在 CPU 中生成，依此类推。 另一方面，如果地址在 CPU 中生成，它要么由固定规则生成（例如，“将程序计数器加 1”），要么由通过管道发送的指令生成，在这种情况下，它的地址必须已经发送过……依此类推。

> Surely there must be a less primitive way of making big changes in the store than by pushing vast numbers of words back and forth through the von Neumann bottleneck. Not only is this tube a literal bottleneck for the data traffic of a problem, but, more importantly, it is an intellectual bottleneck that has kept us tied to word-at-a-time thinking instead of encouraging us to think in terms of the larger conceptual units of the task at hand. Thus programming is basically planning and detailing the enormous traffic of words through the von Neumann bottleneck, and much of that traffic concerns not significant data itself but where to find it. 

一定存在比反复通过冯·诺伊曼瓶颈传输大量数据更原始的方法来大幅改变存储器内容。这个管道不仅是程序数据流动的瓶颈，更重要的是，它也是一个智力上的瓶颈，它将我们束缚在逐字处理的思维模式中，而不是鼓励我们从更大的概念单元去思考手头上任务。这使得，编程基本上就是规划和细化这些通过冯·诺伊曼瓶颈的大量数据，其中大部分流量甚至都不是真正重要的数据，而是有关如何找到这些数据的数据。
